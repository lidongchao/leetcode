package superEggDrop887;

import utils.ArrayUtils;

/**
 * 思路 1：动态规划 TLE
 *
 * 设有数组 dp[K+1][N+1]，其中的 dp[i][j] 代表 i 个鸡蛋，j 层楼的解。
 *
 * 考虑 dp[2][6]，如果从第 4 层扔下第 1 个鸡蛋，会出现两种情况：
 *   1. 没有碎，则剩下 2 个鸡蛋，可以选择 5 6 层继续扔，就是 dp[2][2]
 *   2. 碎了，则剩下 1 个鸡蛋，可以选择 1 2 3 层继续扔，也就是 dp[1][3]
 * 此时 dp[2][6]_4 = max(dp[2][2], dp[1][3]) + 1
 * 继续推断可以得到
 * dp[2][6]_6 = max(dp[2][0], dp[1][5]) + 1
 * dp[2][6]_5 = max(dp[2][1], dp[1][4]) + 1
 * dp[2][6]_4 = max(dp[2][2], dp[1][3]) + 1
 * dp[2][6]_3 = max(dp[2][3], dp[1][2]) + 1
 * dp[2][6]_2 = max(dp[2][4], dp[1][1]) + 1
 * dp[2][6]_1 = max(dp[2][5], dp[1][0]) + 1
 *
 * 因此 dp[2][6] = min (dp[2][6]_k) (k=1,2,3,4,5,6)
 *
 * 边界条件：
 * dp[i][0] 等于有 i 个鸡蛋，但是没有可以扔鸡蛋的楼层了，所以值为 0
 * dp[0][j] 等于没有鸡蛋了，但是还有楼层没有确定，所以值为无解
 * dp[i][1] (i!=0) 等于只剩一层楼了，但是鸡蛋还有很多，所以值为 1
 * dp[1][j] (j!=0) 等于只剩一个鸡蛋了，但是还有楼层没有确认，所以必须从低往高依次扔鸡蛋，最差情况需要每一层都扔一次才能确认，所以值为 j
 *
 */
class Solution1 {
    /**
     * 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
     * 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
     * 你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
     * 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
     * 你的目标是确切地知道 F 的值是多少。
     * 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
     *
     * 提示：
     * 1 <= K <= 100
     * 1 <= N <= 10000
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode-cn.com/problems/super-egg-drop
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     * @param K 鸡蛋个数
     * @param N 楼层数
     * @return 确定 F 值的最小移动次数
     */
    public int superEggDrop(int K, int N) {

        if (K == 1) return N;
        if (N == 1) return 1;

        int[][] dp = new int[K + 1][N + 1];

        for (int i = 0; i <= K; i++) {
            dp[i][0] = 0;  // 很多鸡蛋，没有楼层需要确认
            dp[i][1] = 1;  // 很多鸡蛋，只剩一个楼层需要确认
        }
        for (int j = 0; j <= N; j++) {
            dp[0][j] = 0;  // 应该填无解，不过只是用于占位，便于理解 i 和 j，没有任何其他用途，所以填写 0
            dp[1][j] = j;  // 很多楼层需要确认，只有一个鸡蛋
        }

        // 时间复杂度 O(KNN)
        for (int i = 2; i <= K; i++) {
            for (int j = 2; j <= N; j++) {
                int min = Integer.MAX_VALUE;
                for (int k = 0; k < j; k++) {
                    min = Math.min(min, Math.max(dp[i][k], dp[i-1][j-k-1]));
                }
                dp[i][j] = min + 1;
            }
        }

        System.out.println(ArrayUtils.toStringInt2DRichArray(dp));

        return dp[K][N];
    }
}
