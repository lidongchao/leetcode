package translateNumLcof_46;

import java.util.ArrayList;
import java.util.Collections;

/**
 * 思路 2：动态规划 dp
 *
 * 定义 dp[i] 是转换到 i 时共有多少种转换方法
 *
 * 以 1 2 2 5 8 1 2 为例
 *
 * dp[0] = 1; (1)
 * dp[1] = 2; (1,2) (12)
 * dp[2] = 3; (1,2,2) (1,22) (12,2)
 * dp[3] = 5; (1,2,2,5) (1,2,25) (1,22,5) (12,2,5) (12,25)
 * dp[4] = 5; (1,2,2,5,8) (1,2,25,8) (1,22,5,8) (12,2,5,8) (12,25,8)
 * dp[5] = 5; (1,2,2,5,8,1) (1,2,25,8,1) (1,22,5,8,1) (12,2,5,8,1) (12,25,8,1)
 * dp[6] = 10; (1,2,2,5,8,1,2) (1,2,25,8,1,2) (1,22,5,8,1,2) (12,2,5,8,1,2) (12,25,8,1,2),
 *             (1,2,2,5,8,12)  (1,2,25,8,12)  (1,22,5,8,12)  (12,2,5,8,12)  (12,25,8,12)
 *
 *  1 2 2 5 8 1 2
 * ------------------
 * |0|1|1|2|0|0|5 |  <- 从左开始截止到该数字，该数字和前一个数字组合转换的种类 combine
 * |1|1|2|3|5|5|5 |  <- 从左开始截止到该数字，该数字独立转换的种类 alone
 * |1|2|3|5|5|5|10|  <- 从左开始截止到该数字，该数字所有转换方法的总类 dp
 *
 * combine[i] = (10 <= num[i-1..i] <= 25) ? alone[i-1] : 0
 * alone[i] = combine[i-1] + alone[i-1] = dp[i-1]
 * dp[i] = combine[i] + alone[i]
 *       = (10 <= num[i-1..i] <= 25) ? alone[i-1] + alone[i] : alone[i]
 *       = (10 <= num[i-1..i] <= 25) ? dp[i-2] + dp[i-1] : dp[i-1]
 *
 * 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
 * 内存消耗 :36.7 MB, 在所有 Java 提交中击败了100.00%的用户
 */
class Solution2 {
    /**
     * 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。
     * 一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
     *  
     * 示例 1:
     * 输入: 12258
     * 输出: 5
     * 解释: 12258有5种不同的翻译，分别是"bccfi" (1,2,3,5,8), "bwfi" (1,22,5,8), "bczi" (1,2,25,8), "mcfi" (12,2,5,8)
     * 和"mzi" (12,25,8)
     *  
     * 提示：
     * 0 <= num < 2^31
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     * @param num 待翻译的数字
     * @return 多少种翻译方法
     */
    public int translateNum(int num) {
        // dp[i] = (10 <= num[i-1..i] <= 25) ? dp[i-2] + dp[i-1] : dp[i-1]
        if (num == 0) return 1;
        int mod = num % 100;
        if (mod >= 10 && mod < 26) {
            return translateNum(num / 10) + translateNum(num / 100);
        } else {
            return translateNum(num / 10);
        }
    }
}
