package majorityElement169;

/**
 * 思路 1：假设有一个计数器，当遇到数组中的多数元素时加一，遇到少数元素时减一，那么遍历完数组之后，计数器必然大于0。
 * 或者说，从数组中每次选出两个不同的元素剔出数组，一直操作直到无法继续，此时数组中剩下的元素必然是多数元素。
 *
 * 因此，可以设置一个计数器，初始化为 0，然后开始遍历数组。
 * 当计数器为 0 时，我们就把即将遇到的任何一个元素假设为多数元素。
 * 如果存在假设中的多数元素，那么就把即将遇到的元素与多数元素相比较，相同则计数器加一，不相同则减一。
 * 当计数器减为 0 时，我们就抛弃掉假设的多数元素，把之前遍历过的所有元素视为两两不同的元素相互被剔出数组，再从接下来的数组中重新选多数元素。
 *
 * 执行用时 :2 ms, 在所有 Java 提交中击败了85.34%的用户
 * 内存消耗 :41.2 MB, 在所有 Java 提交中击败了64.30%的用户
 */
class Solution1 {
    /**
     * 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
     * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode-cn.com/problems/majority-element
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     * @param nums 包含多数元素的数组
     * @return 数组中的多数元素
     */
    public int majorityElement(int[] nums) {
        int ans = 0;
        int cnt = 0;
        for (int i : nums) {
            // 计数开始，或者前面没有分出多数元素，将当前元素当作多数元素，计数器由零变为一
            // 如果是后者的情况，那么前面的元素统统作废，计数重新开始，因为从剩下的元素中找到的多数元素，等同于从全部元素中找到的多数元素
            if (cnt == 0) {
                ans = i;
                cnt++;
            }
            // 遇到了多数元素，继续加一
            else if (i == ans) {
                cnt++;
            }
            // 遇到了少数元素，减一
            else {
                cnt--;
            }
        }
        return ans;
    }
}
